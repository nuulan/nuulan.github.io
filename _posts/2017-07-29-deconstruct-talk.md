---
layout: post
title:  "\"Programming Languages as Notations\" at Deconstruct 2017"
date:   2017-07-29
categories: projects
hieroglyph: "&#x13170;"
---

Last April, I attended <strike><a href="https://twitter.com/hashtag/GaryConf?src=hash">GaryConf</a></strike> <strike><a href="https://www.destroyallsoftware.com/talks/wat">WATCON</a></strike> [Deconstruct](http://deconstructconf.com/) 2017, got to listen to some excellent speakers, and enjoyed the opportunity to give a talk of my own: <i>Programming Languages as Notations</i>. [Here are the slides](/assets/csvoss-deconstructconf-2017.pdf).

When I was deciding what to talk about, I had been reading a bunch about the history of notations in math and physics. It's really fascinating how different people throughout history have designed different languages for representing fundamentally identical concepts – for example, we have different notations for arithmetic, different notations for solving problems in quantum electrodynamics, and different notations for manipulating vectors. Some thoughts on each of these I'd like to share:

* **Arithmetic**: Compare Western civilization's arithmetic notation and algorithms (for addition, multiplication, division, and fractions) to the notation and algorithms used in [Ancient Egyptian mathematics](https://en.wikipedia.org/wiki/Ancient_Egyptian_mathematics). I didn't end up mentioning Ancient Egyptian arithmetic in my talk, but it's neat. [*Count Like An Egyptian*](https://blogs.scientificamerican.com/roots-of-unity/learn-to-count-like-an-egyptian/) by David Reimer is a fun resource for learning more.

* **Quantum electrodynamics**: Although two techniques – brute-force algebra and Feynman diagrams – each target the same kinds of problem (quantum electrodynamics calculations), Feynman diagrams are an interesting innovation both because they create both a new abstraction for dealing with those problems at a higher level and because they represent that abstraction in a beautifully visual way. Read David Kaiser's article [*Physics and Feynman's Diagrams*](http://web.mit.edu/dikaiser/www/FdsAmSci.pdf) for some neat history here, or check out his book [*Drawing Theories Apart*](http://web.mit.edu/dikaiser/www/DrawingTheoriesApart.html) for a more in-depth look. I love finding examples of mathematical notations that provide a new abstraction over the problems they solve, and I love highly visual notations, so Feynman diagrams really hit my aesthetic buttons.

* **Vector notation** is another example of a notation that creates a new abstraction: when we represent doubling some three-dimensional vector by writing down the notation 2**x** instead of &#x3008;2x&#x2081;, 2x&#x2082;, 2x&#x2083;&#x3009;, for example, the vector abstraction has saved us from something that's much like code duplication, and in the process has reduced the number of opportunities we have to accidentally introduce an error. Also, vector notation provides a hilarious example of [Standardization Wars](https://xkcd.com/927/) happening over one hundred years ago. Florian Cajori in his work *A History of Mathematical Notation* describes some of the vitriol that got thrown back and forth; some choice quotes from that book are in my slides. It's nice to know (I suppose) that the modern impulse to fight over standards and their implementation details was shared by our ancestors as well.

Because notation had been on my mind, my talk centers around some parallels I see between mathematical notation design and programming language design.

One of those parallels: I like it when I find new programming paradigms that introduce new abstractions for the problems that we as programmers often solve. Here are some things in this general concept-space that have recently piqued my interest:
* [**Dafny**](http://rise4fun.com/dafny) is a research programming language that has syntax built in for writing down a function's preconditions (`requires`) and postconditions (`ensures`); the verifier then checks that those conditions are true.
* **Computational biology** has a need for programming tools that model at many different levels of abstraction – from the molecular level (e.g. protein folding: tools – projects like [Folding@Home](http://folding.stanford.edu/) and [Foldit](https://fold.it/portal/)) to the cellular level (e.g. protein signalling networks: tools – programming languages like [Kappa](http://dev.executableknowledge.org/)) to the whole-organism level (tools – we need them!).
* The [**pi-calculus**](https://en.wikipedia.org/wiki/%CE%A0-calculus) is a model of computation in the same way that lambda calculus or Turing machines are models of computation, but is unusual in that it allows both *parallel composition* and *sequential composition* of code. Normally we write code sequentially, without the ability to specify when two operations or sequences of operations are independent and could very well have happened in parallel. Instead, the pi-calculus formalizes the ability to specify code as running sequentially or in parallel, opening up the possibility that the compiler could optimize code to run concurrently both more easily and with less thought required from the programmer. [Pict](http://www.cis.upenn.edu/~bcpierce/papers/pict/Html/Pict.html) is a concurrent programming language which is built upon the pi-calculus.

Another of those parallels: I like it when I find programming tools that enable visual representation of code. For example, [snakefood](http://grokcode.com/864/snakefooding-python-code-for-complexity-visualization/) is pretty nifty. Towards giving an example of what a *completely* visual programming language could look like, I discuss a visual circuitry-like notation I designed for lambda calculus, giving examples that dive into lambda calculus and combinatory logic. [This blog post](/projects/2015/11/08/lambda-circuitry.html) has more detail on that project. I don't claim that we should be using visual representations all the time – user interface design is tricky, and our text-based systems have a lot going for them – but I think there still exist areas in which to innovate visually.
